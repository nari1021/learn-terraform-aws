# 파일 및 디렉토리

## 1. 파일 확장자
### 1). 파일 확장자
일반 텍스트 파일에 저장되는 `.tf`, json 기반 변형의 `.tf.json` 확장자 사용

### 2). 텍스트 인코딩
구성 파일은 항상 UTF-8 인코딩을 사용
일반적으로 Windows 스타일 줄 끝(CRLF)보다 Unix 스타일 줄 끝(LF)를 사용하지만 둘 다 허용된다.

### 3). 디렉토리 및 모듈
1. Terraform module
    - 디렉토리의 최상위 구성 파일로만 구성
    - 중첩 디렉토리는 완전히 별도의 모듈로 취급되고 구성에 자동으로 포함되지 않는다.
    - 모듈 호출을 사용하여 다른 모듈을 구성에 명시적으로 포함할 수 있다.
    - 이러한 하위 모듈은 로컬 디렉토리(상위 모듈의 디렉토리 또는 디스크의 다른 위치에 중첩) 또는 Terraform Registry와 같은 외부 소스에서 가져올 수 있다.

- Terraform은 모듈의 모든 구성 파일을 평가하여 전체 모듈을 단일 문서로 효과적으로 처리한다.

### 4). 루트 모듈
- Terraform은 항상 단일 루트 모듈의 컨텍스트에서 실행된다.
- 완전한 Terraform 구성은 루트 모듈과 하위 모듈의 트리(루트 모듈에서 호출한 모듈, 해당 모듈에서 호출한 모듈 등 포함)으로 구성된다.
- Terraform CLI에서 루트 모듈 = Terraform이 호출되는 작업 디렉토리
    -> 명령행 옵션을 사용해서 작업 디렉토리 외부에 루트 모듈을 지정할 수 있지만 실제로는 드물다.
- Terraform Cloud 및 Terraform Enterprise에서 작업 공간의 루트 모듈은 기본적으로 구성 디렉토리의 최상위 수준(버전 제어 리포지토리 또는 직접 업로드를 통해 제공됨)으로 설정되지만, 작업 공간 설정은 대신 사용할 하위 디렉토리를 지정할 수 있다.

## 2. 파일 재정의

별도 파일에 있는 기존 구성 개체의 특정 부분을 재정의 할 수 있다.
Terraform은 이름이 `_override.tf`로 끝나는 구성 파일을 `_override.tf.json`으로 처리하고, `override.tf` 는 `override.tf.json`으로 적용된다.

Terraform은 처음에 구성을 로드할 때, 재정의 파일을 건너뛴 다음 나중에 각 파일을 사전 순으로 처리한다. 재정의 파일에 정의된 각 최상위 블록에 대해 Terraform은 해당 블록에 해당하는 이미 정의된 개체를 찾은 다음 재정의 블록 내용을 기존 개체에 병합을 시도한다.

재정의 파일을 사용할 때 원본 파일의 주석을 사용하여 어떤 재정의 파일이 각 블록에 변경 사항을 적용하는지 알려주는 것이 좋다.

### 1). 병합 동작

각 블록 유형에 따라 약간 다르며, 특정 블록 내의 일부 특수 구성은 특별한 방식으로 병합된다.

대부분의 경우에 적용되는 일반 규칙은 아래와 같다.
    - 재정의 파일의 최상위 블록은 동일한 블록 헤더를 가진 일반 구성 파일의 블록과 병합. 블록헤더란 블록 유형과 그 뒤에 오는 따옴표 붙은 레이블이다.
    - 최상위 블록 내에서 재정의 블록 내의 속성 인수는 원래 블록에서 같은 이름의 인수를 대체한다.
    - 최상위 블록 내에서 재정의 블록 내의 모든 중첩 블록은 원래 블록에서 동일한 유형의 모든 블록을 대체한다. 재정의 블록에 나타나지 않는 모든 블록 유형은 원래 블록에서 그대로 유지된다.
    - 중첩된 구성 블록의 내용은 병합되지않는다.
    - 결과적으로 병합된 블록은 여전히 주어진 블록 유형에 적용되는 유효성 검사 규칙을 준수해야한다.

재정의 파일이 둘 이상일 경우, 재정의 효과가 복합되어서 이후 블록이 이전 블록보다 우선된다. 재정의는 먼저 파일 이름(사전순)별로 처리된 다음 각 파일의 위치별로 처리된다.

</br>

밑에서 특정 최상위 블록 유형 내의 특정 인수에 적용되는 특수 병합 동작에 대해 설명한다.

### 2). 병합 `resource` 및 `data` 차단

resource 블록 내에서 lifecycle 중첩 블록의 내용은 인수별로 병합된다.
- 재정의 `resource`블록에 하나 이상의 블록이 포함되어 있으면 원래 블록의 모든 `provisioner` 블록이 무시된다.
- 재정의 `resource`블록에 블록이 포함되어 있으면 원래 블록에 있는 모든 `connection`블록을 완전히 재정의한다.
- `depends_on` 메타 인수는 차단 무시에 사용되지 않을 수 있으며 오류가 발생한다.

### 3). `variable` 블록 병합

`variable`블록 내의 인수는 위에서 설명한 표준 방식으로 병합되지만 `type`및 `default`인수 간의 상호 작용으로 인해 몇 가지 특별한 고려 사항이 적용된다.

- 원래 블록이 `default`값을 정의하고 재정의 블록이 변수를 변경하는 `type`경우 Terraform은 기본값을 재정의된 유형으로 변환하려고 시도하며 이 변환이 불가능하면 오류를 생성한다.
- 반대로 원래 블록을 정의하고 `type`재정의 블록을 변경하는 `default`경우 재정의된 기본값은 원래 유형 사양과 호환되어야 한다.

### 4). `output` 블록 병합

`depends_on` 메타 인수는 차단 무시에 사용되지 않을 수 있으며 오류 발생

### 5). `locals` 블록 병합

각 locals 블록은 여러 명명된 값을 정의하며, 재정의는 정의된 locals 블록을 무시하고 값별로 적용한다.

### 6). `terraform` 블록 병합

`terraform` 블록 내의 설정은 병합할 때 개별적으로 고려된다.

- `required_version` 및 `required_providers` 설정 모두에서 각 재지정 구속조건은 원래 동일한 구성요소에 대한 구속조건을 완전히 대체한다.
- `required_providers` 인수는 재정의 블록이 다른 공급자의 제약에 영향을 주지 않고 단일 공급자에 대한 제약 조건을 조정할 수 있는 원소별 기준에 병합된다.
- 기본 블록과 재정의 블록이 모두 설정되어 있으면 기본 블록 `required_version`의 제약 조건이 완전히 무시된다.

</br></br>

## 3. 종속성 잠금 파일

Terraform 구성은 자체 코드베이스 외부에서 오는 두 가지 종류의 외부 종속성을 참조할 수 있다.
- `providers` : 다양한 외부 시스템과의 상호 작용을 지원하도록 확장하는 Terraform용 플러그인
- `module` : Terraform 구성 그룹을 재사용 가능하도록 추상화로 분할시킨 것

현재 종속성 잠금 파일은 공급자 종속성만 추적한다.

### 1). 파일 위치 잠금

- 잠금 파일의 이름은 항상 `.terraform.lock.hcl`
- Terraform이 `.terraform` 작업 디렉토리의 하위 디렉토리에 캐시하는 다양한 항목에 대한 잠금 파일임을 나타내기 위한 것이다.
- `terraform init` 명령을 실행할 때마다 종속성 잠금 파일을 자동으로 생성하거나 업데이트한다.
- 종속성 잠금 파일은 기본 Terraform 언어와 동일한 하위 수준 구문을 사용하지만 종속성 잠금 파일 자체는 Terraform 언어 구성파일이 아니다. 그 차이를 나타내기위해 `.hcl` 접미사로 명명되었다.

### 2). 종속성 설치 동작

- 특정 제공자가 기존에 기록된 선택 항목에 없다면, Terraform은 주어진 버전 제약 조건과 일치하는 사용 가능한 최신 버전을 선택한 다음 해당 선택 항목을 포함하도록 잠금 파일을 업데이트한다.
- 이미 특정 공급자가 잠금 파일에 선택 항목을 기록한 경우, `-upgrade` 옵션을 추가하여 실행하면 해당 동작을 재정의할 수 있다.

### 3). 체크섬 확인

Terraform은 설치한 각 패키지가 이전에 잠금 파일에 기록된 체크섬이 있다면 그 중 하나 이상과 일치하는지 확인한다. 일치하는 체크섬이 없으면 오류를 반환한다.

체크섬을 확인하는 이유는 `최초 사용 접근 방식에 대한 신뢰`를 나타내기 위한 것이다.
